package edu.stanford.ee368.flowchargenerator.imageproc;
//package opencv;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;

public class PrePro {
	/**
	 * 
	 * @param mat: input image
	 * @return Mat[]:
	 * Mat[0] = rectangles
	 * Mat[1] = diamonds
	 * Mat[2] = arrows
	 */

	static int[] PARAMS = new int[]{100,50,10,50,30,5,100,100,3,35,40};
	static Map<Integer, String> map = new HashMap<>();

	static void initParams() {
		map.put(0, "SMALL_REGION_REMOVAL_THRESHOLD");
		map.put(1, "OPEN_SMALL_REGION_REMOVAL");
		map.put(2, "ARROW_OPEN_RADIUS");
		map.put(3, "HOUGH_THRESHOLD");
		map.put(4, "HOUGH_MIN_LINE_LENGTH");
		map.put(5, "HOUGH_MAX_LINE_GAP");
		map.put(6, "CANNY_THRESHOLD_1");
		map.put(7, "CANNY_THRESHOLD_2");
		map.put(8, "CANNY_APETURE_SIZE");
		map.put(9, "ADAPTIVE_THRESHOLD_BLOCKSIZE");
		map.put(10, "ADAPTIVE_THRESHOLD_C");
	}

	public static String getParamNameByIndex(int i) {
		return map.get(i);
	}



	public static Mat[] prepro(Mat mat){
		initParams();
//		int SMALL_REGION_REMOVAL_THRESHOLD = 100;
//		int OPEN_SMALL_REGION_REMOVAL = 50;
//		int ARROW_OPEN_RADIUS = 10;
//		int HOUGH_THRESHOLD = 50;
//		int HOUGH_MIN_LINE_LENGTH = 30;
//		int HOUGH_MAX_LINE_GAP = 5;
//		int CANNY_THRESHOLD_1 = 100;
//		int CANNY_THRESHOLD_2 = 100;
//		int CANNY_APETURE_SIZE = 3;
//		int ADAPTIVE_THRESHOLD_BLOCKSIZE = 35;
//		int ADAPTIVE_THRESHOLD_C = 40;

		int SMALL_REGION_REMOVAL_THRESHOLD = PARAMS[0];
		int OPEN_SMALL_REGION_REMOVAL = PARAMS[1];
		int ARROW_OPEN_RADIUS = PARAMS[2];
		int HOUGH_THRESHOLD =PARAMS[3];
		int HOUGH_MIN_LINE_LENGTH = PARAMS[4];
		int HOUGH_MAX_LINE_GAP = PARAMS[5];
		int CANNY_THRESHOLD_1 = PARAMS[6];
		int CANNY_THRESHOLD_2 = PARAMS[7];
		int CANNY_APETURE_SIZE = PARAMS[8];
		int ADAPTIVE_THRESHOLD_BLOCKSIZE = PARAMS[9];
		int ADAPTIVE_THRESHOLD_C = PARAMS[10];

		try {
			System.out.println("Hello, World!");

			// get mat size
			int rows = mat.rows();
			int cols = mat.cols();

			// rgb2gray, generate gray image
			Mat gray = new Mat(rows,cols,CvType.CV_8UC1);
			Imgproc.cvtColor(mat, gray, Imgproc.COLOR_RGB2GRAY);
			System.out.println("Grayscale Done!");

			// binarize, generate new mat
			Mat bina = new Mat(rows, cols, CvType.CV_8UC1);
			Imgproc.adaptiveThreshold(gray, bina, 255, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, ADAPTIVE_THRESHOLD_BLOCKSIZE, ADAPTIVE_THRESHOLD_C);
			System.out.println("Binarization Done!");

			// bit inverted
			Core.bitwise_not(bina, bina); 
			System.out.println("BitWiseNot Done!");

			// denoise and fill

			Mat denoise = denoiseAndFill(bina, SMALL_REGION_REMOVAL_THRESHOLD);

			// get edges
			Mat edges = new Mat(rows, cols, CvType.CV_8UC1);
			Imgproc.Canny(denoise, edges, CANNY_THRESHOLD_1, CANNY_THRESHOLD_2, CANNY_APETURE_SIZE, false);
			System.out.println("GetEdge Done!");

			// hough transform
			Mat substitute = new Mat();
			Mat lines = new Mat(rows, cols, CvType.CV_8UC1);

			Imgproc.HoughLinesP(edges, lines, 1, Math.PI / 180.0, HOUGH_THRESHOLD, HOUGH_MIN_LINE_LENGTH, HOUGH_MAX_LINE_GAP);

			// rotate
			if(lines.rows() > 0) {
			    Mat rotated = rotate(denoise, lines);
				// parameter update
				cols = rotated.cols();
				rows = rotated.rows();
				substitute = rotated.clone();
			} else {
				substitute = denoise.clone();
			}

			// find contours
			int smallRegion = 100;
			Mat fill = denoiseAndFill(substitute, smallRegion);

			// open to eliminate arrows

			Mat seOpen = seGen(ARROW_OPEN_RADIUS);
			Mat opened = new Mat(rows, cols, CvType.CV_8UC1);
			Imgproc.morphologyEx(fill, opened, Imgproc.MORPH_OPEN, seOpen);
			System.out.println("Open Done!");

			// compute difference to get arrows
			Mat diff = new Mat(rows, cols, CvType.CV_8UC1);
			Core.absdiff(fill, opened, diff);
			System.out.println("Diff Done!");

			// remove small area generated by open

//			int smallArea = 150;
			Mat remv = denoiseAndFill(diff, OPEN_SMALL_REGION_REMOVAL);

			// get rectangles and diamonds
			Mat blob = new Mat(rows, cols, CvType.CV_8UC1);
			Core.absdiff(fill, remv, blob);
			System.out.println("Blob Done!");

			// distinguish rectangles and diamonds
			Mat[] rectAndDiam = genRectAndDiam(blob);
			Mat rectangle = rectAndDiam[0];
			Mat diamond = rectAndDiam[1];

			// erode
			Mat eroded_rect = erode(rectangle, 10);
			Mat eroded_diam = erode(diamond, 10);

			// get boxes
			Mat rect = new Mat(rows, cols, CvType.CV_8UC1);
			Core.absdiff(rectangle, eroded_rect, rect);
			Mat diam = new Mat(rows, cols, CvType.CV_8UC1);
			Core.absdiff(diamond, eroded_diam, diam);
			System.out.println("Box Done!");

			// type conversion
			Mat[] result = new Mat[3];
			result[0] = rect;
			result[1] = diam;
			result[2] = remv;
			System.out.println("Conversion Done!");

			return result;

		} catch (Exception e) {
			System.out.println("Error: " + e.getMessage());
		}
		return null;
	}	
	
	// rotate
	public static Mat rotate(Mat m, Mat houghLines) {
		int[] nums = new int[houghLines.rows() * 4];
		double[] angles = new double[houghLines.rows()];
		houghLines.get(0, 0, nums);
		for(int i = 0; i < houghLines.rows() ; i++) {
			double x1 = nums[4 * i];
			double y1 = nums[4 * i + 1];
			double x2 = nums[4 * i + 2];
			double y2 = nums[4 * i + 3];
			angles[i] = Math.atan((y2 - y1) / (x2 - x1));
		}
		Arrays.sort(angles);
		double angle = angles[angles.length / 2];
		double degree = Math.toDegrees(angle);
		System.out.println("Hough Transform Done!");

		// image rotate
		int x = m.cols();
		int y = m.rows();
		// 4 points, (0, 0) (x, 0) (0, y) (x, y) to rotate transform (clockwise)
		// (0, 0), (x*cosA, -x*sinA) (y*sinA, y*cosA) (x*cosA+y*sinA, -x*sinA+y*cosA)
		int newWidth = 0;
		int newHeight = 0;
		int xshift = 0;
		int yshift = 0;
		if(angle >= 0) {
			newWidth = (int) Math.round(x * Math.cos(angle) + y * Math.sin(angle));
			newHeight = (int) Math.round(y * Math.cos(angle) + x * Math.sin(angle));
			yshift = (int) Math.round(x * Math.sin(angle));
		} else { // angle < 0
			newWidth = (int) Math.round(x * Math.cos(angle) - y * Math.sin(angle));
			newHeight = (int) Math.round(-x * Math.sin(angle) + y * Math.cos(angle));
			xshift = (int) Math.round(-y * Math.sin(angle));
		}

		// shift image
		Mat shifted = Mat.zeros(y + yshift, x + xshift, CvType.CV_8UC1);
		Mat shiftedSub = shifted.submat(yshift, y + yshift, xshift, x + xshift);
		m.copyTo(shiftedSub);
		System.out.println("Shift Done!");

		// rotate image
		Mat rotMat = Imgproc.getRotationMatrix2D(new org.opencv.core.Point(xshift, yshift), degree, 1.0);
		Mat rotated = new Mat();
		Imgproc.warpAffine(shifted, rotated, rotMat, new Size(newWidth, newHeight), Imgproc.INTER_LINEAR);			
		System.out.println("Rotation Done!");
		
		return rotated;
	}
	
	// distinguish rectangle and diamond
	public static Mat[] genRectAndDiam(Mat m) {
		List<MatOfPoint> blobContours = new ArrayList<>();
		Mat rectangle = Mat.zeros(m.size(), CvType.CV_8UC1);
		Mat diamond = Mat.zeros(m.size(),  CvType.CV_8UC1);
		Scalar white = new Scalar(255);
		Imgproc.findContours(m, blobContours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
		for (MatOfPoint contour: blobContours) {
			 double actualArea = Imgproc.contourArea(contour);
			 Rect bounding = Imgproc.boundingRect(contour);
			 double boundingArea = bounding.width * bounding.height;
			 if(actualArea / boundingArea > 0.75) {	// rectangular
				 Imgproc.fillPoly(rectangle, Arrays.asList(contour), white);
			 } else {	// diamond
				 Imgproc.fillPoly(diamond, Arrays.asList(contour), white);
			 }
		}
		System.out.println("Rectangle Diamond Done!");
		return new Mat[]{rectangle, diamond};
	}
	
	// remove small area
	public static Mat denoiseAndFill(Mat m, int thres) {
		List<MatOfPoint> noiseContours = new ArrayList<>();
		Mat denoise = Mat.zeros(m.rows(), m.cols(), CvType.CV_8UC1);
		Scalar white = new Scalar(255);
		Imgproc.findContours(m, noiseContours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
		for (MatOfPoint contour: noiseContours) {
			if(contour.rows() > thres) {
				Imgproc.fillPoly(denoise, Arrays.asList(contour), white);
			}
		}
		System.out.println("Denoise Done!");
		return denoise;
	}
	
	// erode
	public static Mat erode(Mat m, int r) {
		Mat seErode = seGen(r);
		Mat eroded = new Mat(m.rows(), m.cols(), CvType.CV_8UC1);
		Imgproc.erode(m, eroded, seErode);
		System.out.println("Erode Done!");
		return eroded;
	}

	// 2D square to 1D array
	public static int[] TwoDim2OneDim(int[][] input, int size) {
		int[] output = new int[size * size];
		for(int r = 0; r < size; r++) {
			for(int c = 0; c < size; c++) {
				output[c + r * size] = input[r][c];
			}
		}
		return output;
	}

	// structuring element generation
	public static Mat seGen(int radius) {
		int diameter = 2 * radius + 1;
		int[][] disk = new int[diameter][diameter];
		for(int x = 0; x < diameter; x++) {
			for(int y = 0; y < diameter; y++) {
				int xpos = x - 10;
				int ypos = y - 10;
				if(xpos*xpos + ypos*ypos <= radius*radius) {
					disk[x][y] = 1;
				} else {
					disk[x][y] = 0;
				}
			}
		}
		int[] diskFlat = TwoDim2OneDim(disk, diameter);
		Mat seOpen = new Mat(diameter, diameter, CvType.CV_32SC1);
		seOpen.put(0, 0, diskFlat);
		seOpen.convertTo(seOpen, CvType.CV_8UC1);
		return seOpen;
	}

	public static void addParam(int i) {
		PARAMS[i]++;
	}

	public static void minusParam(int i) {
		PARAMS[i]--;
	}

	public static int getParamsSize() {
		return PARAMS.length;
	}

	public static int getParam(int i) {
		return PARAMS[i];
	}
}
